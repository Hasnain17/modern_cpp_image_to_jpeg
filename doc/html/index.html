<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Modern CPP Features - Image File Converter: Modern C++17 (and some C++14) features in practise</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Modern CPP Features - Image File Converter
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Modern C++17 (and some C++14) features in practise </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This project shows off a few of the new core language additions as well as std enhancements and is a tool to auto-convert all recognised image files in a given directory or on a web-page to jpg files.</p>
<p>Implemented are a C++17 version of the toojpeg library (~600 LOC), an http 'socket' (~600 LOC), a webpage-crawler (~100 LOC).</p>
<p>Used external libraries and header-only libraries: openSSL for https and <code>stb_image.h</code> for loading images.</p>
<p>A benchmark binary downloads and loads a 2d-projected picture of the earth (<a href="https://upload.wikimedia.org/wikipedia/commons/3/3d/Eckert4.jpg,">https://upload.wikimedia.org/wikipedia/commons/3/3d/Eckert4.jpg,</a> 1.6MB, Creative Commons License) and writes it with the original and re-implemented toojpeg library. Find benchmark results at the end of this document.</p>
<h2>Documentation</h2>
<p>The code is Doxygen-compatible documented. Build the documentation via <code>cmake</code> and <code>make doc</code>. A prebuild documentation is checked-in at <code>doc/html</code>.</p>
<h2>Tests</h2>
<p>Tests are stored in the <code>tests/</code> directory. Build them with <code>cmake</code> and <code>make tests</code>. A small C++17 featured test harness has been written in tests/tests.h to avoid external dependencies.</p>
<h2>C-legacy</h2>
<p>Throughout this project C-legacy has been avoided as much as possible. This includes old-style casts, C-Posix API (except the net <a class="el" href="namespaceSocket.html" title="A simple URL parser type.">Socket</a> API) and the C preprocessor (macros).</p>
<p>For example:</p><ul>
<li><code>std::array&lt;uint8_t,8*8&gt;</code> instead of <code>uint8_t data[8*8]</code></li>
<li><code>std::experimental::source_location</code> instead of <code>__LINE__</code>, <code>__FILE</code> etc</li>
<li><code>constexpr</code> instead of macros and for conditional compilations</li>
</ul>
<p>C-Libraries like the stb_image library have been properly C++ type wrapped to take advantage of RAII etc.</p>
<h2>C++17 version of the toojpeg library</h2>
<p>The original toojpeg only uses C++11 <code>auto</code> keyword and is apart from that pretty much C++03. Its code size, many precomputed lookup tables and numeric values and the IO related domain makes it a good candidate to experiment with C++17 features.</p>
<h4>Modern Application Programming Interfaces</h4>
<p>Having an API that cannot (un)intentionally being misused while offering an efficient interface is essential. Ideally the API expresses the developers intention via the C++ type system in regard to input arguments lifetime and ownership.</p>
<p>C++17 added the <code>nodiscard</code> attribute so that the compilers warn if return values are not used. <code>noexcept</code> allows the compiler to avoid generating stack-unwinding code for functions that will never throw, which results in better runtime performance if exceptions are enabled:</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">[[nodiscard]] const char * data() const noexcept {/*...*/}</div></div><!-- fragment --><p>Smart pointers are used to express ownership:</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">explicit BitWriter(std::unique_ptr&lt;std::ostream&gt; &amp;&amp;output_) : output(std::move(output_)) {}</div></div><!-- fragment --><p>While in a non-owning situation, raw pointers and custom (wrapper) types like <code><a class="el" href="structByteView.html" title="A non-owned byte range.">ByteView</a></code> (a pointer + size) are the correct choice:</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">BitWriter &amp;operator&lt;&lt;(ByteView data) { output-&gt;write(data.data(), data.size()); return *this; }</div><div class="line"></div><div class="line">bool writeJpeg(..., const uint8_t *pixels, ...) {/*...*/}</div></div><!-- fragment --><p>The new <code>std::byte</code> type (C++17) has been used, instead of (unsigned) <code>char</code>s. To quote cppreference: </p><blockquote class="doxtable">
<p>"std::byte is a distinct type that implements the concept of byte as specified in the C++ language definition." </p>
</blockquote>
<p>To accommodate the fact that <code>std::byte</code> cannot simply (implicitly) being created via a integral number, a (constexpr) user-defined literal (C++14) helps out (usage: <code>0xff_bn</code>):</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">constexpr std::byte operator &quot;&quot; _bn(unsigned long long v) { return std::byte(v); }</div></div><!-- fragment --><p>And finally new composed data types like <code>std::optional</code>, <code>std::any</code>, <code>std::variant</code> (and the existing <code>std::tuple</code>) and automatic destructuring ("Structured binding declaration") of those (C++17) allow for richer return types:</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">constexpr auto scaled_luminance_chrominance(...) -&gt; std::tuple&lt;std::array&lt;...&gt;, std::array&lt;...&gt;&gt; {</div><div class="line">    /* ... */</div><div class="line">    return std::make_tuple(scaledLuminance, scaledChrominance);</div><div class="line">}</div><div class="line"></div><div class="line">/// Structured binding declaration</div><div class="line">auto [scaledLuminance, scaledChrominance] = scaled_luminance_chrominance(...);</div></div><!-- fragment --><h4>Compile-time precompute with <code>constexpr</code></h4>
<p>It is not unusual to be in the situation of deciding within space vs time tradeoff bounds. A C++ developer up to C++17 may have favoured runtime computations or "magical constants", just because it is more convenient than writing an external generator tool and include that and the results in a buildsystem.</p>
<p>With C++17 <code>constexpr</code> got much more expressive (temporary state like inline variables are supported) and it will be extended even more with C++20 (const-boundary aware heap usage).</p>
<p>In this project in multiple occasions <code>constexpr</code> was used, eg to eliminate "magical numbers":</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">// Before</div><div class="line">const auto SqrtHalfSqrt = 1.306562965f;</div><div class="line">// After</div><div class="line">constexpr double SqrtHalfSqrt = sqrt((2 + sqrt(2)) / 2);</div></div><!-- fragment --><p>C++ does not yet offer <code>constexpr</code> math (an RFC exists), but implementing the approximation for the square root for example is done in just a few lines: </p><div class="fragment"><div class="line"> {c++}</div><div class="line">double constexpr sqrt(double x) { return sqrt_helper(x, x, 0); }</div><div class="line">double constexpr sqrt_helper(double x, double curr, double prev) {</div><div class="line">    return is_close(curr, prev) ? curr : sqrt_helper(x, 0.5 * (curr + x / curr), curr);</div><div class="line">}</div><div class="line">constexpr auto is_close(T a, T b) -&gt; bool {</div><div class="line">    return std::abs(a - b) &lt;= std::numeric_limits&lt;T&gt;::epsilon() * std::abs(a + b)</div><div class="line">           || std::abs(a - b) &lt; std::numeric_limits&lt;T&gt;::min();</div><div class="line">}</div></div><!-- fragment --><p>Especially useful is <code>constexpr</code> to pre-compute lookup tables for example the huffman table (see <code>constexpr std::array&lt;BitCode, 256&gt; generateHuffmanTable(const uint8_t numCodes[16], const uint8_t *values)</code> in <code>toojpeg_17.hpp</code>), and quantisation tables (in <code>constexpr auto quant_table(const std::array&lt;uint8_t, 8 * 8&gt; defaults) -&gt; std::array&lt;std::byte, 8 * 8&gt;</code>).</p>
<p>This allows to use the exact math writen in the original papers (often modulo, division) as we do not need to care about runtime penalties.</p>
<div class="fragment"><div class="line"> {c++}</div><div class="line">// Before (faster but not obvious substitutions)</div><div class="line">auto row = ZigZagInv[i] &gt;&gt; 3;</div><div class="line">auto column = ZigZagInv[i] &amp; 7;</div><div class="line">// After</div><div class="line">auto row = ZigZagInv[i] / 8;</div><div class="line">auto column = ZigZagInv[i] % 8;</div></div><!-- fragment --><h2>Http / TCP <a class="el" href="namespaceSocket.html" title="A simple URL parser type.">Socket</a></h2>
<p>A tiny, blocking http tcp socket type has been implemented for this tool, based on the Posix socket and network C-API. As with all C-wrapping types, RAII is build on for resource management (socket closing, resource freeing), which also works with the error handling strategy (exceptions).</p>
<blockquote class="doxtable">
<p>IMO: As soon as <code>std::expected</code> is part of C++ (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r3.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r3.pdf</a>), I will instantly swap out runtime costly exception usage. See also examples in <a href="https://github.com/TartanLlama/expected">https://github.com/TartanLlama/expected</a>. </p>
</blockquote>
<p>Although the type can be conditionally compiled with and without SSL support (via openSSL), the implementation avoids massive usage of <code>#ifdef</code>s.</p>
<p>Instead C++17's <code>__has_include</code> for conditional header including and type traits in combination with <code>std::enable_if</code> (and a bit of SFINAE) have been used. </p><div class="fragment"><div class="line"> {c++}</div><div class="line">/// with ssl</div><div class="line">template&lt;bool with_https_ = with_https, typename = std::enable_if_t&lt;with_https_, std::size_t&gt;&gt;</div><div class="line">[[nodiscard]] std::size_t read_from_socket(std::enable_if_t&lt;with_https_, std::size_t&gt; dataRead) {</div><div class="line">    return cSSL_ ? // Runtime decision if this is an SSL socket</div><div class="line">           SSL_read(cSSL_, this-&gt;buffer_.data() + dataRead, this-&gt;buffer_.size() - dataRead) :</div><div class="line">           read(getSocketId(), this-&gt;buffer_.data() + dataRead, this-&gt;buffer_.size() - dataRead);</div><div class="line">}</div><div class="line"></div><div class="line">// without ssl</div><div class="line">template&lt;bool with_https_ = with_https, typename = std::enable_if_t&lt;!with_https_, std::size_t&gt;&gt;</div><div class="line">[[nodiscard]] std::size_t read_from_socket(std::size_t dataRead) {</div><div class="line">    return read(getSocketId(), this-&gt;buffer_.data() + dataRead, this-&gt;buffer_.size() - dataRead);</div><div class="line">}</div><div class="line"></div><div class="line">// Conditionally decide what to do, no #ifdef required anymore</div><div class="line">if constexpr (with_https) {</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><h2>Extended C++ std: Regex, Filesystem, Parallel Algorithms</h2>
<p>The filesystem submodule is a massive addition to C++17 and The Standard Library.</p>
<p>This project uses <code>std::filesystem</code> for simple operations like retrieving the current path, removing a file, checking if a file exists, and for more elaborated tasks like enumerating all files, not directories, of a certain directory.</p>
<p>The c++11 <code>std::regex</code> (and implicitly the C++17 <code>std::basic_regex</code> deduction guide) has been used for the webpage image url crawler, found in <code>main.cpp::webpage_crawler</code>.</p>
<p>The parallel algorithm support of C++17's std has been used to read, compute and output multiple files in parallel: </p><div class="fragment"><div class="line"> {c++}</div><div class="line">std::for_each(std::execution::par, std::begin(files), std::end(files), [&amp;](Path&amp; path) {</div><div class="line">  process_file(path, output_dir);</div><div class="line">});</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
